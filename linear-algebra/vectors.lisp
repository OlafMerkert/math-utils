(defpackage :linear-algebra/vectors
  (:nicknames :vectors)
  (:shadow :vector)
  (:use :cl :ol )
  (:export
   :entries
   :vector
   :dimensions
   :mref
   :mref/human
   :indices
   :this))

(in-package :linear-algebra/vectors)

(defclass vector ()
  ((entries :initarg :entries
                 :accessor entries))
  (:documentation "doc"))

(defun dimensions (vector)
  (array-dimensions (entries vector)))

(defun mref (vector-or-matrix &rest indices)
  "access vector or matrix entreis, where indexing start with 0."
  (apply #'aref (entries vector-or-matrix) indices))

(defun set-mref (vector-or-matrix &rest indices+value)
  "setf method for MREF."
  (multiple-value-bind (indices value) (split-last indices+value)
    (setf (apply #'aref (entries vector-or-matrix) indices)
          value)))

(defsetf mref set-mref)

(defun mref/human (vector-or-matrix &rest indices)
  "access vector or matrix entries, where indexing starts with 1."
  (apply #'aref (entries vector-or-matrix)
         (mapcar #'1- indices)))

(defun set-mref/human (vector-or-matrix &rest indices+value)
  "setf method for MMREF."
  (multiple-value-bind (indices value) (split-last indices+value)
    (setf (apply #'aref (entries vector-or-matrix)
                 (mapcar #'1- indices))
          value)))

(defsetf mref/human set-mref/human)

(defsymconstant +unfilled+
    "a symbolic constant to mark unfilled entries in vectors.")

(defun make-vector% (dimensions fill-function)
  "create a new array with given dimensions and use fill-function to
  calculate the entries."
  (declare (inline fill-array))
  (let ((coeff (make-array dimensions :initial-element +unfilled+)))
    (fill-array coeff fill-function dimensions)))

(defun fill-array (array fill-function &optional (positions nil positions?))
  "fill the ARRAY with the FILL-FUNCTION in the places given by
POSITIONS. POSITIONS is a list of index ranges, where an index range
is either a tuple (start end) with inclusive start and exclusive end,
or simply an integer end, equivalent to (0 end). FILL-FUNCTION will be
called in the same way as aref--first argument is the array, the
remaining are the indices. "
  (unless positions?
    (setf positions (array-dimensions array)))
  ;; just reverse the positions once here, so we don't have to reverse
  ;; the index-lists all the time.
  (setf positions (reverse positions))
  (labels ((index-range (position)
             ;; normalise the range information
             (if (listp position)
                 (values (first position) (second position))
                 (values 0 position)))
           (rec (positions indices)
             (if positions
                 ;; more ranges to iterate over
                 (multiple-value-bind (start end) (index-range (first positions))
                   (dotimes+ (i start end)
                       ((rest (rest positions)))
                     (rec rest
                          (cons i indices))))
                 ;; all index information available
                 (setf (apply #'aref        array indices)
                       (apply fill-function array indices)))))
    (rec positions nil)
    ;; return the now filled array
    array))

(ew
  (defun make-vector/general (human dimensions index-vars fill-form)
    "Convenience macro for building vectors, indexing starts with 0 if
human is nil, otherwise with 1. This affects autogenerated index-vars.
The array to be filled can be referenced by this in fill form, but do
not rely on filling order. Autogeneration of index-vars happens for
nil, then you get i0, i1, i2 etc and for t, then you get &rest
indices."
    (unless index-vars
      (setf index-vars (mapcar (lambda (x) (symb 'i (if human (+ 1 x) x)))
                               (lrange dimensions))))
    (when (eq index-vars t)
      (setf index-vars '(&rest indices)))
    (unless (or (member '&rest index-vars)
                (member :list  dimensions)
                (= (length dimensions) (length index-vars)))
      (error "Mismatching dimensions and indices ~A!" index-vars))
    `(make-vector% ,(if (eq (first dimensions) :list)
                        (second dimensions)
                        `(list ,@dimensions))
                   (lambda (this ,@index-vars)
                     (declare (ignorable this ,@(remove '&rest index-vars)))
                     ,@(when human (mapcar #`(incf ,a1) index-vars))
                     ,@fill-form))))

(defmacro make-vector (dimensions index-vars &body fill-form)
  "see make-vector/general for doc (with human = nil)"
  (make-vector/general nil dimensions index-vars fill-form))

(defmacro make-vector/human (dimensions index-vars &body fill-form)
  "see make-vector/general for doc (with human = t)"
  (make-vector/general t dimensions index-vars fill-form))

(defun dimensions-compatible-p (&rest vectors)
  "test whether the given vectors have the same dimensions, so we can
elementwise operations."
  (case (length vectors)
    ((0) (error "no vector given for dimensions test."))
    ((1) (dimensions (first vectors)))
    (t   (let ((dimensions-of-vectors
                (mapcar #'dimensions vectors)))
           (when (apply #'equal dimensions-of-vectors)
             (first dimensions-of-vectors))))))

(defmacro elementwise-operation (vectors &body fill-form)
  "create a new vector with same dimensions as vectors (a list of
  symbols referencing actual vectors), where every field is filled
  with fill-form, where every vector symbol stands for the
  corresponding field."
  (let ((coeffs (list->gensyms :entries vectors)))
    `(let ,(mapcar #2`(,a1 (entries ,a2)) coeffs vectors)
       (make-vector (:list (dimensions-compatible-p ,@vectors)) t
           (symbol-macrolet
               ,(mapcar #2`(,a2 (apply #'aref ,a1 indices)) coeffs vectors)
             ,@fill-form)))))

;;; generic operations for vectors

(defmethod gm:generic-+ ((vector-a vector) (vector-b vector))
  (elementwise-operation (vector-a vector-b)
    (gm:+ vector-a vector-b)))

(defmethod gm:generic-- ((vector-a vector) (vector-b vector))
  (elementwise-operation (vector-a vector-b)
    (gm:- vector-a vector-b)))

(defmethod gm:generic-* ((vector-a vector) (vector-b vector))
  (elementwise-operation (vector-a vector-b)
    (gm:* vector-a vector-b)))

(defmethod gm:generic-/ ((vector-a vector) (vector-b vector))
  (elementwise-operation (vector-a vector-b)
    (gm:/ vector-a vector-b)))
